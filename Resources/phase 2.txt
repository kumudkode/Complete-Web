Phase 2: JavaScript Surgeons ğŸ§‘ğŸ»â€âš•ï¸ - Complete Learning Guide
1. JavaScript Basics â€“ The Language of the Web
Introduction to JavaScript
JavaScript is a versatile programming language primarily used for creating interactive elements on websites. Unlike HTML (structure) and CSS (presentation), JavaScript adds behavior to web pages.

Key roles of JavaScript:

+Dynamic content updates
+Form validation
+Animations and visual effects
+Responding to user events
+Communicating with servers (APIs)
Variables and Data Types
JavaScript has several fundamental data types:
// Primitive data types
let myString = "Hello World";        // String - text
let myNumber = 42;                   // Number - integers and decimals
let isActive = true;                 // Boolean - true/false
let noValue = null;                  // Null - intentional absence of value
let notDefined;                      // Undefined - variable declared but not assigned

// Reference data types
let myArray = [1, 2, 3, "apple"];    // Array - ordered collection
let myObject = {                     // Object - collection of key-value pairs
  name: "John",
  age: 30
};

Visual representation of data types:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       JavaScript Data Types       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Primitive    â”‚    Reference      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ String     â”‚    â€¢ Object       â”‚
â”‚  â€¢ Number     â”‚    â€¢ Array        â”‚
â”‚  â€¢ Boolean    â”‚    â€¢ Function     â”‚
â”‚  â€¢ Null       â”‚    â€¢ Date         â”‚
â”‚  â€¢ Undefined  â”‚    â€¢ RegExp       â”‚
â”‚  â€¢ Symbol     â”‚    â€¢ Map/Set      â”‚
â”‚  â€¢ BigInt     â”‚                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Variable Declaration
Best practice: Use const by default, and only use let when you need to reassign values.
// var - function scoped, can be redeclared (avoid in modern code)
var oldSchool = "I'm function scoped";

// let - block scoped, can be reassigned
let counter = 0;
counter = 1; // Valid reassignment

// const - block scoped, cannot be reassigned
const PI = 3.14159;
// PI = 3; // Error: Assignment to constant variable

Understanding Scope
// Global scope - accessible everywhere
const globalVar = "I'm global!";

function exampleFunction() {
  // Function scope - accessible only inside this function
  const functionVar = "I'm function-scoped";
  
  if (true) {
    // Block scope - accessible only inside this block
    const blockVar = "I'm block-scoped";
    let blockLet = "I'm also block-scoped";
    var notBlockScoped = "I'm function-scoped despite being in a block";
    
    console.log(blockVar);      // Accessible
    console.log(functionVar);   // Accessible
    console.log(globalVar);     // Accessible
  }
  
  // console.log(blockVar);     // Error: not defined here
  console.log(notBlockScoped);  // Accessible (var ignores block scope)
}
Visual representation of scope:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Global Scope                                    â”‚
â”‚                                                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Function Scope                              â”‚ â”‚
â”‚ â”‚                                             â”‚ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚ â”‚ â”‚ Block Scope                             â”‚ â”‚ â”‚
â”‚ â”‚ â”‚                                         â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ let and const respect this boundary     â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ var ignores this boundary               â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚ â”‚                                             â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Hoisting
JavaScript "hoists" declarations to the top of their scope during compilation:
// What you write:
console.log(hoistedVar); // undefined (not an error!)
var hoistedVar = "I was hoisted!";

// How JavaScript interprets it:
var hoistedVar;
console.log(hoistedVar); // undefined
hoistedVar = "I was hoisted!";

// let and const are hoisted but not initialized:
// console.log(hoistedLet); // Error: Cannot access before initialization
let hoistedLet = "I'm hoisted but not initialized!";



####Basic Operators
// Arithmetic operators
let sum = 5 + 3;        // 8  (addition)
let difference = 10 - 4; // 6  (subtraction)
let product = 7 * 3;     // 21 (multiplication)
let quotient = 20 / 4;   // 5  (division)
let remainder = 10 % 3;  // 1  (modulus/remainder)
let power = 2 ** 3;      // 8  (exponentiation)

// Comparison operators
5 == "5"    // true  (equality - converts types)
5 === "5"   // false (strict equality - checks type and value)
5 != "6"    // true  (inequality)
5 !== "5"   // true  (strict inequality)
7 > 5       // true  (greater than)
5 < 10      // true  (less than)
5 >= 5      // true  (greater than or equal to)
5 <= 4      // false (less than or equal to)

// Logical operators
true && false  // false (AND - both must be true)
true || false  // true  (OR - at least one must be true)
!true          // false (NOT - negates the value)

Control Flow

// if statement
let temperature = 75;

if (temperature > 80) {
  console.log("It's hot outside!");
} else if (temperature > 60) {
  console.log("It's pleasant outside!");
} else {
  console.log("It's cold outside!");
}

// switch statement
let day = "Monday";

switch (day) {
  case "Monday":
    console.log("Start of the work week");
    break;
  case "Friday":
    console.log("End of the work week");
    break;
  case "Saturday":
  case "Sunday":
    console.log("Weekend!");
    break;
  default:
    console.log("Midweek");
}

// ternary operator
let age = 20;
let canVote = age >= 18 ? "Yes" : "No";
console.log(canVote); // "Yes"


2. Functions â€“ Building Blocks of JavaScript
What is a Function?
A function is a reusable block of code designed to perform a specific task. Functions help organize code, reduce repetition, and make your code more maintainable.

// Basic syntax
function sayHello() {
  console.log("Hello, World!");
}

// Call the function
sayHello(); // "Hello, World!"



##Function Declaration vs Expression
// Function declaration - can be called before it's defined (hoisted)
function multiply(a, b) {
  return a * b;
}

// Function expression - cannot be called before it's defined
const divide = function(a, b) {
  return a / b;
};

console.log(multiply(5, 3)); // 15
console.log(divide(10, 2));  // 5

**Visual comparison:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Function Declaration          â”‚ â”‚ Function Expression           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ function name(params) {       â”‚ â”‚ const name = function(params) {â”‚
â”‚   // code                     â”‚ â”‚   // code                     â”‚
â”‚ }                             â”‚ â”‚ };                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ Hoisted (can be used       â”‚ â”‚ âœ— Not hoisted in the same way â”‚
â”‚   before declaration)         â”‚ â”‚                               â”‚
â”‚ âœ“ Clear distinction in code  â”‚ â”‚ âœ“ Can be anonymous            â”‚
â”‚                               â”‚ â”‚ âœ“ Can be used as argument     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜



##Arrow Functions
Arrow functions provide a shorter syntax and lexically bind the this value:
// Traditional function
const square = function(x) {
  return x * x;
};

// Arrow function (single parameter)
const squareArrow = x => x * x;

// Arrow function (multiple parameters)
const add = (a, b) => a + b;

// Arrow function with function body
const greet = name => {
  const greeting = `Hello, ${name}!`;
  return greeting;
};

console.log(square(5));     // 25
console.log(squareArrow(5)); // 25
console.log(add(3, 7));      // 10
console.log(greet("Alice")); // "Hello, Alice!"


##Function Parameters and Return

// Parameters - values passed to functions
function greetPerson(name, greeting = "Hello") {
  return `${greeting}, ${name}!`;
}

// Return values
console.log(greetPerson("Maria"));          // "Hello, Maria!"
console.log(greetPerson("John", "Welcome")); // "Welcome, John!"

// Functions that don't return anything
function logMessage(message) {
  console.log(message);
  // No return statement (implicitly returns undefined)
}

const result = logMessage("Testing");
console.log(result); // undefined


Closures
A closure occurs when a function "remembers" its lexical scope even when executed outside that scope.

function createCounter() {
  let count = 0;  // Private variable
  
  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// Each counter function has its own private count variable
const counter2 = createCounter();
console.log(counter2()); // 1 (not affected by counter)


**Visual representation of a closure:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ createCounter function                  â”‚
â”‚                                         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ let count = 0                       â”‚ â”‚
â”‚ â”‚                                     â”‚ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚ â”‚ â”‚ return function() {            â”‚ â”‚ â”‚
â”‚ â”‚ â”‚   count++;                     â”‚ â”‚ â”‚
â”‚ â”‚ â”‚   return count;                â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ }                              â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚ â”‚                â–²                    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ const counter =  â”‚                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
                                          â”‚
  When counter() is called, it still has  â”‚
  access to the count variable even thoughâ”‚
  createCounter has finished executing    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. Arrays and Objects â€“ Working with Data
Arrays
## Arrays are ordered collections of values that can be of any type.

// Creating arrays
let fruits = ["Apple", "Banana", "Cherry"];
let mixed = [1, "two", true, null, {name: "Object"}, [1, 2]];

// Accessing elements (zero-based indexing)
console.log(fruits[0]); // "Apple"
console.log(fruits[2]); // "Cherry"

// Array length
console.log(fruits.length); // 3

// Basic array methods
fruits.push("Date");        // Add to end: ["Apple", "Banana", "Cherry", "Date"]
let lastFruit = fruits.pop(); // Remove from end: ["Apple", "Banana", "Cherry"]
console.log(lastFruit);     // "Date"

fruits.unshift("Apricot");   // Add to start: ["Apricot", "Apple", "Banana", "Cherry"]
let firstFruit = fruits.shift(); // Remove from start: ["Apple", "Banana", "Cherry"]
console.log(firstFruit);    // "Apricot"

// Finding elements
console.log(fruits.indexOf("Banana")); // 1
console.log(fruits.includes("Mango")); // false


## Advanced Array Methods
let numbers = [1, 2, 3, 4, 5];

// map - transform each element
let doubled = numbers.map(function(num) {
  return num * 2;
});
console.log(doubled); // [2, 4, 6, 8, 10]

// filter - keep elements that pass a test
let evenNumbers = numbers.filter(function(num) {
  return num % 2 === 0;
});
console.log(evenNumbers); // [2, 4]

// reduce - accumulate values
let sum = numbers.reduce(function(total, num) {
  return total + num;
}, 0);
console.log(sum); // 15 (1+2+3+4+5)

// forEach - execute function for each element
numbers.forEach(function(num) {
  console.log(num * 2);
});
// Outputs: 2, 4, 6, 8, 10


**Visual representation of array methods:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Array Methods Visualization with [1, 2, 3, 4, 5]             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Method       â”‚ Visualization                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ map          â”‚ [1, 2, 3, 4, 5] â†’ [2, 4, 6, 8, 10]            â”‚
â”‚              â”‚  â†‘  â†‘  â†‘  â†‘  â†‘     â†‘  â†‘  â†‘  â†‘  â†‘              â”‚
â”‚              â”‚  x2 x2 x2 x2 x2     2  4  6  8 10             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ filter       â”‚ [1, 2, 3, 4, 5] â†’ [2, 4]                      â”‚
â”‚              â”‚  â•³  âœ“  â•³  âœ“  â•³                               â”‚
â”‚              â”‚ odd even odd even odd                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ reduce       â”‚ [1, 2, 3, 4, 5] â†’ 15                          â”‚
â”‚              â”‚   â•²â•²_â•²â•²_â•²â•²_â•²â•²_/                               â”‚
â”‚              â”‚    0+1+2+3+4+5                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Objects
Objects store data as key-value pairs:

// Creating objects
let person = {
  firstName: "John",
  lastName: "Doe",
  age: 30,
  hobbies: ["reading", "music", "sports"],
  address: {
    street: "123 Main St",
    city: "New York",
    country: "USA"
  }
};

// Accessing properties
console.log(person.firstName);        // "John"
console.log(person["lastName"]);      // "Doe" (bracket notation)
console.log(person.hobbies[1]);       // "music"
console.log(person.address.city);     // "New York"

// Adding/modifying properties
person.email = "john@example.com";    // Add new property
person.age = 31;                     // Modify existing property

// Object methods
let keys = Object.keys(person);      // ["firstName", "lastName", "age", "hobbies", "address", "email"]
let values = Object.values(person);  // [Array of values]
let entries = Object.entries(person); // [Array of [key, value] pairs]


##Object Methods
// Adding methods to objects
let calculator = {
  add: function(a, b) {
    return a + b;
  },
  
  // Shorthand method syntax (ES6)
  subtract(a, b) {
    return a - b;
  },
  
  multiply(a, b) {
    return a * b;
  }
};

console.log(calculator.add(5, 3));      // 8
console.log(calculator.subtract(10, 4)); // 6
console.log(calculator.multiply(2, 3));  // 6


## Iterating Over Arrays and Objects
// Iterating over arrays
let colors = ["red", "green", "blue"];

// Traditional for loop
for (let i = 0; i < colors.length; i++) {
  console.log(colors[i]);
}

// for...of loop (iterates over values)
for (let color of colors) {
  console.log(color);
}

// Iterating over objects
let user = {name: "Alice", age: 25, role: "Admin"};

// for...in loop (iterates over keys)
for (let key in user) {
  console.log(`${key}: ${user[key]}`);
}

// Object.entries with for...of
for (let [key, value] of Object.entries(user)) {
  console.log(`${key}: ${value}`);
}


4. Asynchronous JavaScript â€“ Handling Time-sensitive Code
What is Asynchronous Programming?
JavaScript is single-threaded, meaning it can do only one thing at a time. Asynchronous programming allows JavaScript to perform operations without blocking the main thread.

Visual representation of synchronous vs asynchronous:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Synchronous                       â”‚ â”‚ Asynchronous                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Task A  â†’  Task B  â†’  Task C      â”‚ â”‚ Task A  â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’  Done    â”‚
â”‚                                   â”‚ â”‚    â†“                              â”‚
â”‚ (Each task waits for previous     â”‚ â”‚ Task B  â†’â†’â†’â†’â†’â†’â†’  Done             â”‚
â”‚  task to complete)                â”‚ â”‚       â†“                           â”‚
â”‚                                   â”‚ â”‚    Task C  â†’â†’â†’  Done              â”‚
â”‚                                   â”‚ â”‚                                   â”‚
â”‚                                   â”‚ â”‚ (Tasks run in parallel)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


##setTimeout and setInterval
// setTimeout - run once after a delay
console.log("Start");

setTimeout(function() {
  console.log("This runs after 2 seconds");
}, 2000); // Time in milliseconds

console.log("End");
// Output: "Start", "End", "This runs after 2 seconds"

// setInterval - run repeatedly at specified intervals
let counter = 0;
const intervalId = setInterval(function() {
  counter++;
  console.log(`Counter: ${counter}`);
  
  if (counter >= 5) {
    clearInterval(intervalId); // Stop the interval
    console.log("Interval stopped");
  }
}, 1000);


Callbacks
A callback is a function passed as an argument to another function, which is then invoked inside the outer function.

// Simple callback example
function fetchData(callback) {
  setTimeout(function() {
    const data = {id: 1, name: "Product"};
    callback(data);
  }, 2000);
}

fetchData(function(data) {
  console.log("Data received:", data);
});

// Callback hell - nested callbacks making code hard to follow
fetchData(function(data) {
  console.log("First data:", data);
  fetchMoreData(data.id, function(moreData) {
    console.log("Second data:", moreData);
    processData(moreData, function(result) {
      console.log("Processed result:", result);
      // More nesting...
    });
  });
});

Visual representation of callback hell:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Callback Hell                                  â”‚
â”‚                                                â”‚
â”‚ fetchData(function(data) {                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ fetchMoreData(data.id, function(more) { â”‚  â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚   â”‚   â”‚ processData(more, function(res) {â”‚  â”‚  â”‚
â”‚   â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚
â”‚   â”‚   â”‚   â”‚ saveResult(res, function {â”‚  â”‚  â”‚  â”‚
â”‚   â”‚   â”‚   â”‚   // More callbacks...    â”‚  â”‚  â”‚  â”‚
â”‚   â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚
â”‚   â”‚   â”‚ });                              â”‚  â”‚  â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚   â”‚ });                                     â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚ });                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Promises
Promises provide a cleaner way to handle asynchronous operations.
// Creating a promise
function fetchDataPromise() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = true;
      
      if (success) {
        resolve({id: 1, name: "Product"});
      } else {
        reject(new Error("Failed to fetch data"));
      }
    }, 2000);
  });
}

// Using a promise
fetchDataPromise()
  .then(data => {
    console.log("Data received:", data);
    return processDataPromise(data);
  })
  .then(result => {
    console.log("Processed result:", result);
    return saveResultPromise(result);
  })
  .then(saveResponse => {
    console.log("Save response:", saveResponse);
  })
  .catch(error => {
    console.error("Error:", error.message);
  })
  .finally(() => {
    console.log("Operation completed (success or failure)");
  });


Visual representation of promises:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Promise Chain                                  â”‚
â”‚                                                â”‚
â”‚ fetchDataPromise()                             â”‚
â”‚  â”‚                                             â”‚
â”‚  â–¼                                             â”‚
â”‚ .then(data => processDataPromise(data))        â”‚
â”‚  â”‚                                             â”‚
â”‚  â–¼                                             â”‚
â”‚ .then(result => saveResultPromise(result))     â”‚
â”‚  â”‚                                             â”‚
â”‚  â–¼                                             â”‚
â”‚ .then(saveResponse => console.log(saveResponse))â”‚
â”‚  â”‚                                             â”‚
â”‚  â”‚  If any step fails                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                     â–¼                          â”‚
â”‚                .catch(error => handleError)    â”‚
â”‚                     â”‚                          â”‚
â”‚                     â–¼                          â”‚
â”‚                .finally(() => cleanUp)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Async/Await
Async/await is syntactic sugar over promises, making asynchronous code look more like synchronous code.
// Async function declaration
async function fetchAndProcessData() {
  try {
    // Await suspends execution until promise resolves
    const data = await fetchDataPromise();
    console.log("Data received:", data);
    
    const result = await processDataPromise(data);
    console.log("Processed result:", result);
    
    const saveResponse = await saveResultPromise(result);
    console.log("Save response:", saveResponse);
    
    return saveResponse;
  } catch (error) {
    console.error("Error:", error.message);
  } finally {
    console.log("Operation completed");
  }
}

// Call the async function
fetchAndProcessData().then(finalResult => {
  console.log("Final result:", finalResult);
});



**Comparison of callback, promise, and async/await:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handling Asynchronous Code                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Callbacks       â”‚ Promises        â”‚ Async/Await         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ getData(functionâ”‚ getData()       â”‚ async function run(){â”‚
â”‚   (data) {      â”‚   .then(data => â”‚   try {             â”‚
â”‚     // Use data â”‚     // Use data â”‚     const data =    â”‚
â”‚     getMore(dataâ”‚     return more â”‚       await getData()â”‚
â”‚       function(mâ”‚   })            â”‚     const more =    â”‚
â”‚       ) {       â”‚   .then(more => â”‚       await getMore()â”‚
â”‚         // Use m â”‚     // Use moreâ”‚     // Use data+moreâ”‚
â”‚       }         â”‚   })            â”‚   } catch (error) { â”‚
â”‚     );          â”‚   .catch(error =>â”‚     // Handle err  â”‚
â”‚   }             â”‚     // Handle   â”‚   }                 â”‚
â”‚ );              â”‚   );            â”‚ }                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ— "Callback    â”‚ âœ“ Chainable     â”‚ âœ“ Looks like        â”‚
â”‚   hell" nesting â”‚ âœ“ Built-in     â”‚   synchronous code   â”‚
â”‚ âœ— Error handlingâ”‚   error handlingâ”‚ âœ“ Try/catch for    â”‚
â”‚   is complex    â”‚                 â”‚   error handling    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

5. JavaScript and the DOM â€“ Interacting with the Browser
What is the DOM?
The Document Object Model (DOM) is a programming interface for web documents. It represents the page as a tree of objects that JavaScript can manipulate.

Visual representation of the DOM tree:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DOM Tree                                            â”‚
â”‚                                                     â”‚
â”‚               document                              â”‚
â”‚                   â”‚                                 â”‚
â”‚                   â–¼                                 â”‚
â”‚                 <html>                              â”‚
â”‚                 /     \                             â”‚
â”‚                /       \                            â”‚
â”‚               â–¼         â–¼                           â”‚
â”‚           <head>       <body>                       â”‚
â”‚             â”‚            â”‚                          â”‚
â”‚             â–¼            â–¼                          â”‚
â”‚          <title>      <div>                         â”‚
â”‚             â”‚          / \                          â”‚
â”‚             â–¼         /   \                         â”‚
â”‚         "My Page"    â–¼     â–¼                        â”‚
â”‚                   <h1>    <p>                       â”‚
â”‚                    â”‚       â”‚                        â”‚
â”‚                    â–¼       â–¼                        â”‚
â”‚                "Header"  "Text"                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Accessing DOM Elements

// By ID - returns a single element
const header = document.getElementById('header');

// By class name - returns an HTMLCollection (array-like object)
const navItems = document.getElementsByClassName('nav-item');

// By tag name - returns an HTMLCollection
const paragraphs = document.getElementsByTagName('p');

// CSS selectors - returns the first matching element
const mainContent = document.querySelector('.main-content');

// CSS selectors - returns all matching elements as a NodeList
const buttons = document.querySelectorAll('button.action');

// Traversing the DOM
const parent = header.parentElement;
const firstChild = parent.firstElementChild;
const nextSibling = header.nextElementSibling;


Modifying HTML Content

// Changing text content
header.textContent = 'New Heading';

// Changing HTML content
mainContent.innerHTML = '<p>This is <strong>new</strong> content.</p>';

// Getting and setting attributes
const link = document.querySelector('a');
console.log(link.getAttribute('href'));
link.setAttribute('href', 'https://example.com');
link.setAttribute('target', '_blank');

// Working with form values
const inputField = document.querySelector('input[type="text"]');
inputField.value = 'Default text';


Manipulating Styles

// Direct style manipulation
header.style.color = 'blue';
header.style.backgroundColor = '#f0f0f0';
header.style.fontSize = '24px';

// Working with classes
header.classList.add('highlight');
header.classList.remove('hidden');
header.classList.toggle('active');
const hasClass = header.classList.contains('highlight'); // true


Creating and Removing Elements

// Creating elements
const newParagraph = document.createElement('p');
newParagraph.textContent = 'This is a dynamically created paragraph.';

// Adding elements to the DOM
mainContent.appendChild(newParagraph);

// Inserting before another element
const referenceElement = document.querySelector('.reference');
mainContent.insertBefore(newParagraph, referenceElement);

// Removing elements
newParagraph.remove(); // Modern approach
// Or
if (newParagraph.parentNode) {
  newParagraph.parentNode.removeChild(newParagraph); // Works in older browsers
}


6. Event Handling â€“ Making Web Pages Interactive
Introduction to Events
Events are actions or occurrences that happen in the browser, such as a user clicking a button or the page finishing loading.

Common events:

click: Mouse clicks an element
dblclick: Mouse double-clicks an element
mouseover/mouseout: Mouse enters/leaves an element
keydown/keyup: Keyboard key is pressed/released
submit: Form is submitted
load: Resource and its dependents have finished loading
resize: Window is resized
scroll: Element is scrolled

##Event Listeners
// Basic event listener
const button = document.querySelector('button');
button.addEventListener('click', function() {
  console.log('Button clicked!');
});

// Using named functions
function handleButtonClick() {
  console.log('Button clicked!');
}
button.addEventListener('click', handleButtonClick);

// Removing event listeners
button.removeEventListener('click', handleButtonClick);

// The event object
button.addEventListener('click', function(event) {
  console.log('Event type:', event.type);
  console.log('Target element:', event.target);
  console.log('Mouse coordinates:', event.clientX, event.clientY);
});



Visual representation of event flow:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Button Click Event                                  â”‚
â”‚                                                     â”‚
â”‚ 1. User clicks button                               â”‚
â”‚                                                     â”‚
â”‚ 2. Browser creates event object with details:       â”‚
â”‚    - type: "click"                                  â”‚
â”‚    - target: button element                         â”‚
â”‚    - timestamp                                      â”‚
â”‚    - mouse coordinates                              â”‚
â”‚    - etc.                                           â”‚
â”‚                                                     â”‚
â”‚ 3. Event listener function is called                â”‚
â”‚    with event object as parameter                   â”‚
â”‚                                                     â”‚
â”‚ 4. Function executes and performs actions           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Event Bubbling and Capturing
Events in the DOM propagate in three phases:

Capturing phase: From document down to the target element
Target phase: The event reaches the target element
Bubbling phase: From the target back up to the document

// HTML structure:
// <div id="outer">
//   <div id="inner">
//     <button id="button">Click me</button>
//   </div>
// </div>

const outer = document.getElementById('outer');
const inner = document.getElementById('inner');
const button = document.getElementById('button');

// Bubbling (default - third parameter is false or omitted)
outer.addEventListener('click', function() {
  console.log('Outer div clicked (bubble)');
});

inner.addEventListener('click', function() {
  console.log('Inner div clicked (bubble)');
});

button.addEventListener('click', function() {
  console.log('Button clicked (bubble)');
});

// Capturing (third parameter is true)
outer.addEventListener('click', function() {
  console.log('Outer div clicked (capture)');
}, true);

inner.addEventListener('click', function() {
  console.log('Inner div clicked (capture)');
}, true);

button.addEventListener('click', function() {
  console.log('Button clicked (capture)');
}, true);

// When button is clicked, output is:
// 1. "Outer div clicked (capture)"
// 2. "Inner div clicked (capture)"
// 3. "Button clicked (capture)"
// 4. "Button clicked (bubble)"
// 5. "Inner div clicked (bubble)"
// 6. "Outer div clicked (bubble)"


**Visual representation of event propagation:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Event Propagation                                 â”‚
â”‚                                                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ #outer                                        â”‚ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚ â”‚ â”‚ #inner                                    â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚ #button                               â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚                                       â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚         3. TARGET PHASE               â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚                                       â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚                                           â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚ â”‚                                               â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                   â”‚
â”‚       1. CAPTURING PHASE         2. BUBBLING PHASEâ”‚
â”‚           (top â†’ down)              (bottom â†’ up) â”‚
â”‚               â–¼                         â–²         â”‚
â”‚               â–¼                         â–²         â”‚
â”‚               â–¼                         â–²         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


##Preventing Default Behavior and Stopping Propagation

// Prevent default behavior
const link = document.querySelector('a');
link.addEventListener('click', function(event) {
  event.preventDefault(); // Prevents the link from navigating
  console.log('Link click prevented');
});

// Stop propagation
button.addEventListener('click', function(event) {
  event.stopPropagation(); // Prevents the event from bubbling up
  console.log('Event stopped, parent handlers will not be called');
});

// Stop immediate propagation
button.addEventListener('click', function(event) {
  console.log('First button handler');
  event.stopImmediatePropagation(); // Stops other handlers on the same element
});

button.addEventListener('click', function(event) {
  console.log('Second button handler - will not run');
});


Event Delegation
Event delegation leverages event bubbling to handle events for multiple elements with a single event listener on a parent element.
// Instead of attaching events to each list item:
const list = document.querySelector('ul');

// Use event delegation:
list.addEventListener('click', function(event) {
  // Check if the clicked element is a list item
  if (event.target.tagName === 'LI') {
    console.log('List item clicked:', event.target.textContent);
    // Do something with the list item
    event.target.classList.toggle('selected');
  }
});

// This works even for list items added dynamically later!
const newItem = document.createElement('li');
newItem.textContent = 'New item';
list.appendChild(newItem);


I've covered in detail the first 6 sections of the Phase 2 learning path. Would you like me to continue with sections 7-9 (Object-Oriented JavaScript, Advanced JavaScript Concepts, and ES6+ Features)?

Similar code found with 6 license types - View matches